<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><meta name="baidu-site-verification" content="code-KCMz4b3cnd"><meta name="google-site-verification" content="MTp8U7dJ1uzrfz8Mu6rgqX1CIm3HjqPWd0xaRcv1tFg"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/favicon.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"aisakaaoi.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="工程师能力层级概览对于不同级别的算法工程师技能要求，我们大致可以分成以下几个层级：  初级：可以在一些指导和协助下独立完成开发任务。具体到算法方面，需要你对于工具框架，建模技术，业务特性等方面有一定的了解，可以独立实现一些算法项目上的需求。 中级：可以基本独立完成一个项目的开发与交付。在初级工程师的基础上，对于深入了解技术原理的要求会更高，并且能够应对项目中各种复杂多变的挑战，对于已有技术和工具进"><meta property="og:type" content="article"><meta property="og:title" content="算法工程师技术路线图"><meta property="og:url" content="https://aisakaaoi.github.io/38913555.html"><meta property="og:site_name" content="逢坂葵的个人博客"><meta property="og:description" content="工程师能力层级概览对于不同级别的算法工程师技能要求，我们大致可以分成以下几个层级：  初级：可以在一些指导和协助下独立完成开发任务。具体到算法方面，需要你对于工具框架，建模技术，业务特性等方面有一定的了解，可以独立实现一些算法项目上的需求。 中级：可以基本独立完成一个项目的开发与交付。在初级工程师的基础上，对于深入了解技术原理的要求会更高，并且能够应对项目中各种复杂多变的挑战，对于已有技术和工具进"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-04-16T22:43:08.000Z"><meta property="article:modified_time" content="2026-01-23T11:02:51.538Z"><meta property="article:author" content="Aisaka Aoi"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://aisakaaoi.github.io/38913555.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>算法工程师技术路线图 | 逢坂葵的个人博客</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?7308ed05421777c301eefa3754da1b42",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="逢坂葵的个人博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">aoi学院</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Aisaka's Blog, School of Aoi, Aisaka University</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">20</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">1023</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><a href="https://github.com/AisakaAoi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://aisakaaoi.github.io/38913555.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/manatsu.jpg"><meta itemprop="name" content="Aisaka Aoi"><meta itemprop="description" content="Aisaka's Blog, School of Aoi, Aisaka University"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="逢坂葵的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">算法工程师技术路线图</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-17 06:43:08" itemprop="dateCreated datePublished" datetime="2023-04-17T06:43:08+08:00">2023-04-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%F0%9F%8C%99%E9%80%A2%E5%9D%82%E6%9D%82%E8%B0%88%E4%B8%8E%E6%90%AC%E8%BF%90/" itemprop="url" rel="index"><span itemprop="name">🌙逢坂杂谈与搬运</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%F0%9F%8C%99%E9%80%A2%E5%9D%82%E6%9D%82%E8%B0%88%E4%B8%8E%E6%90%AC%E8%BF%90/%E2%AD%90%E5%AD%A6%E6%9C%AF%E4%BA%BA%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">⭐学术人生</span></a> </span></span><span id="/38913555.html" class="post-meta-item leancloud_visitors" data-flag-title="算法工程师技术路线图" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/38913555.html#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/38913555.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>17k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>41 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="工程师能力层级概览"><a href="#工程师能力层级概览" class="headerlink" title="工程师能力层级概览"></a>工程师能力层级概览</h3><p>对于不同级别的算法工程师技能要求，我们大致可以分成以下几个层级：</p><ul><li>初级：可以在一些指导和协助下独立完成开发任务。具体到算法方面，需要你对于工具框架，建模技术，业务特性等方面有一定的了解，可以独立实现一些算法项目上的需求。</li><li>中级：可以基本独立完成一个项目的开发与交付。在初级工程师的基础上，对于深入了解技术原理的要求会更高，并且能够应对项目中各种复杂多变的挑战，对于已有技术和工具进行改造适配。在整体工程化交付方面，对于代码质量，架构设计，甚至项目管理方面的要求会开始显现。另外从业务出发来评估技术选型和方案也变得尤为重要。</li><li>高级：可以独立负责一条产品线的运作。在中级工程师的基础上，需要更广阔的技术视野与开拓创新能力，定义整个产品线的前进方向。解决问题已经不是关键，更重要的是提出和定义问题，能够打造出在业界具有领先性和差异性的产品，为公司创造更大的价值。</li></ul><p>事实上对于不同层级的工程师，非技术部分的要求都有一定占比。本文主要聚焦在技术路线图上，对于其他方面的学习进阶路线不会做覆盖。</p><span id="more"></span><hr><h3 id="阅读建议"><a href="#阅读建议" class="headerlink" title="阅读建议"></a>阅读建议</h3><p>以下内容分工程基础，算法基础，算法工程交叉，工程深入方向，算法深入方向几个部分，在各个部分内部会进一步区分一些主题。在各个主题内部，也是有深入程度的区别的，不过限于篇幅没有进行详细的说明。建议学习路线可以先把两个基础部分与工作中较为相关的内容做一个整体基础的夯实，然后可以在后续交叉和深入方向的主题中选择感兴趣的进行深入了解和学习，过程中发现基础部分欠缺的，可以再回到基础部分查漏补缺，迭代前行。</p><hr><h3 id="工程基础"><a href="#工程基础" class="headerlink" title="工程基础"></a>工程基础</h3><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p>Python是算法工程师日常工作中最常用的语言，应该作为必须掌握的一门技术。大致的学习路线如下：</p><ul><li>学习掌握Python的基本语法，可以通过各类入门教程来看，个人推荐《Learn Python the Hard Way》。<ul><li>自我考核：能够读懂大多数的内部项目及一些开源项目代码的基本模块，例如pandas, sklearn等。</li></ul></li><li>学习Python的编程风格，建议学习观远内部的Python代码规范。<ul><li>自我考核：编写的代码符合编码规范，能够通过各类lint检查。</li></ul></li><li>Python进阶，这方面有一本非常著名的书《Fluent Python》，深入介绍了Python内部的很多工作原理，读完之后对于各类疑难问题的理解排查，以及语言高级特性的应用方面会很有帮助。另外动态语言元编程这块，《Ruby元编程》也是一本非常值得推荐的书。<ul><li>自我考核：能够读懂一些复杂的Python项目，例如sqlalchemy中就大量使用了元编程技巧。在实际工程项目中，能够找到一些应用高级技巧的点进行实践，例如基于Cython的性能优化等。</li></ul></li><li>领域应用，Python的应用相当广泛，在各个领域深入下去都有很多可以学习的内容，比如Web开发，爬虫，运维工具，数据处理，机器学习等。这块主要就看大家各自的兴趣来做自由选择了，个人推荐熟悉了解一下Python web开发，测试开发相关的内容，开拓视野。<ul><li>自我考核：以Web开发和测试开发为例，尝试写一个简单的model serving http服务，并编写相应的自动化测试。</li></ul></li></ul><h5 id="Scala-x2F-Java"><a href="#Scala-x2F-Java" class="headerlink" title="Scala&#x2F;Java"></a>Scala&#x2F;Java</h5><p>Java目前是企业级开发中最常用的软件，包括在大数据领域，也是应用最广泛的语言，例如当年的Hadoop生态基本都是基于Java开发的。Scala由于其函数式编程的特性，在做数据处理方面提供了非常方便的API，也因为Spark等项目的火热，形成了一定的流行度。在进行企业级的软件开发，高性能，大规模数据处理等方面，JVM上的这两门语言有很大的实用价值，值得学习。</p><p>顺带一提，Scala本身是一门非常有意思的语言，其中函数式编程的思想与设计模式又是非常大的一块内容，对于拓宽视野，陶冶情操都是挺不错的选择。</p><p>考虑到算法工程师的工作内容属性，这边给出一个Scala的学习路线：</p><ul><li><p>学习掌握Scala的基本语法，开发环境配置，项目编译运行等基础知识。这里推荐Coursera上Martin Odersky的课程，《快学Scala》或《Programming in Scala》两本书也可以搭配着浏览参考。</p><ul><li>自我考核：能使用Scala来实现一些简单算法问题，例如DFS&#x2F;BFS。或者使用Scala来处理一些日常数据工作，例如读取日志文件，提取一些关键信息等。</li></ul></li><li><p>学习使用Scala来开发Spark应用，推荐edX上的《Big Data Analytics Using Spark》或者Coursera上的《Big Data Analytics with Scala and Spark》，另外有些相关书籍也可以参考，比如《Spark快速大数据分析》等。</p><ul><li>自我考核：能够使用Spark的Scala API来进行大规模的数据分析及处理，完成lag feature之类的特征工程处理。</li></ul></li><li><p>JVM的原理学习，Scala&#x2F;Java都是JVM上运行的优秀语言，其背后是一个非常大的生态，包括在Web，Android，数据基础架构等方面有广泛的应用。JVM相比Python虚拟机，发展更加成熟，有一套非常完善的JDK工具链及衍生的各类项目，便于开发者debug，调优应用。这方面推荐学习周志明的《深入理解Java虚拟机》。</p><ul><li>自我考核：理解JVM GC原理，能通过JDK中相关工具或者优秀的第三方工具如arthas等，排查分析Spark数据应用的资源使用情况，GC profiling，hot method profiling等，进而进行参数优化。</li></ul></li><li><p>计算机语言理论。Programming Language作为计算机科学的一个重要分支，包含了很多值得深入研究的主题，例如类型论，程序分析，泛型，元编程，DSL，编译原理等。这方面的很多话题，在机器学习方面也有很多实际应用，比如TVM这类工作，涉及到大量编译原理的应用，知乎大佬“蓝色”也作为这个领域的专家在从事深度学习框架相关的工作。llvm, clang作者Chris Lattner也加入Google主导了Swift for Tensorflow等工作。Scala作为一门学术范非常强的语言，拥有极佳的FP，元编程等能力支持，强大的类型系统包括自动推理，泛型等等高级语言特性，相对来说是一门非常“值得”学习的新语言，也是一个进入PL领域深入学习的”gateway drug” :) 对这个方面有兴趣的同学，可以考虑阅读《Scala函数式编程》，《冒号课堂》，以及Coursera上《Programming Languages》也是一门非常好的课程。另外只想做科普级了解的同学，也可以读一读著名的《黑客与画家》感受一下。</p></li></ul><h5 id="C-x2F-C-x2F-Rust"><a href="#C-x2F-C-x2F-Rust" class="headerlink" title="C&#x2F;C++&#x2F;Rust"></a>C&#x2F;C++&#x2F;Rust</h5><p>当前流行的算法框架，例如TensorFlow, PyTorch, LightGBM等，底层都是基于C++为主要语言进行实现的。但是C++本身过于复杂，使用场景也比较有限制，建议只需要达到能够读懂一些基础的C++代码逻辑即可。在系统级开发领域，目前有一门新语言逐渐崛起，连续几年被StackOverflow投票评选为程序员最喜爱的语言：Rust。从设计理念和一些业界应用（例如TiKV）来看还是非常不错的，但是我也没有深入学习了解过，就不做具体推荐了。这方面建议的学习内容包括经典的《The C Programming Language》以及Rust官方的：<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rustlings">https://github.com/rust-lang/rustlings</a></p><p>自我考核：能够读懂LightGBM里对于tweedie loss的相关定义代码。</p><hr><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>我们所编写的算法应用，都是通过操作系统的环境运行在物理硬件之上的。在实际运作过程中，会碰到不少相关的问题，例如为什么程序报了资源不足的错误，为什么notebook在浏览器里打不开，为什么进程hang住了没有响应等等，都需要一些操作系统的知识来帮助理解和分析问题，最终排查解决。操作系统涵盖的内容比较多，建议一开始只需要了解一些主要概念（例如硬件结构，CPU调度，进程，线程，内存管理，文件系统，IO，网络等），对于整体图景有一些感觉即可。后续碰到了实际问题，可以再在各个部分深入学习展开。优秀的学习资料也有很多，基本都是大部头，重点推荐《深入理解计算机系统》，《Operating Systems: Three Easy Pieces》，以及《现代操作系统》。</p><p>自我考核：能够基本明确运行一个模型训练任务过程中，底层使用到的硬件，操作系统组件，及其交互运作的方式是如何的。</p><h5 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h5><p>平时工作中最常用的两个操作系统CentOS和macOS，都是Unix&#x2F;Linux系的，因此学习掌握相关的基础知识非常重要。一些必须掌握的知识点包括：Shell与命令行工具，软件包管理，用户及权限，系统进程管理，文件系统基础等。这方面的入门学习资料推荐《鸟哥的Linux私房菜》，基本涵盖了Linux系统管理员需要掌握知识的方方面面。进阶可以阅读《Unix环境高级编程》，对于各种系统调用的讲解非常深入，可以为后续性能调优等高级应用打下基础。</p><p>自我考核：开发一个shell小工具，实现一些日常工作需求，例如定时自动清理数据文件夹中超过一定年龄的数据文件，自动清理内存占用较大且运行时间较久的jupyter notebook进程等。</p><h5 id="深入应用"><a href="#深入应用" class="headerlink" title="深入应用"></a>深入应用</h5><p>工作中碰到的疑难问题排查，性能分析与优化，系统运维及稳定性工程等方面，都需要较为深入的计算机体系和操作系统知识，感兴趣的同学可以针对性的进行深入学习。以性能优化为例，可以学习经典的《性能之巅》，了解其中的原理及高级工具链。像其中的系统调用追踪(strace)，动态追踪(systemtap, DTrace, perf, eBPF)等技术，对于操作系统相关的问题排查都会很有帮助。</p><p>自我考核：能够分析定位出LightGBM训练过程中的性能瓶颈，精确到函数调用甚至代码行号的级别。</p><hr><h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><h5 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h5><p>暂时先把这块放到软件工程模块下。这里指的算法是计算机科学中的经典算法，例如递归，排序，搜索，动态规划等，有别于我们常说的机器学习算法。这块的学习资料网上有非常多，个人当年是通过普林斯顿的算法课(需要有Java基础)入门，后来又上了斯坦福的算法分析与设计，开拓了一些视野。书籍方面推荐新手从《算法图解》入门，然后可以考虑阅读Jeff Erickson的《Algorithms》，或者选择上面提到的网课。另外像《编程珠玑》，《编程之美》等也可以参阅，里面有不少问题的巧妙解法。除了从书本中学习，还可以直接去LeetCode等网站进行实战操作进行练习提高。</p><p>自我考核：能够设计相关的数据结构，实现一个类似airflow中点击任意节点向后运行的功能。</p><h5 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h5><p>从初级程序员到中高级程序员，其中比较大的一个差异就是代码编写习惯上，从一开始写计算机能理解，能够运行成功的代码，逐渐演化到写人能够理解，易于修改与维护的代码。在这条学习路径上，首先需要建立起这方面的意识，然后需要在实战中反复思考和打磨自己的代码，评判和学习其它优秀的项目代码，才能逐渐精进。推荐的学习书籍有《编写可读代码的艺术》，一本非常短小精悍的入门书籍，后续可以再慢慢阅读那些经典大部头，例如《Clean Code》，《Code Complete》，《The Pragmatic Programmer》等。这方面Python也有一本比较针对性的书籍《Effective Python》，值得一读。</p><p>自我考核：审视自己写的项目代码，能发现并修正至少三处不符合最佳编码实践的问题。</p><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>在代码架构方面，设计模式是一个重要的话题，对于日常工作中出现的许多典型场景，给出了一些解决方案的“套路”。这方面最著名的书当属GoF的《设计模式》，不过个人并不十分推荐，尤其是以Python作为主要工作语言的话，其中很大部分的设计模式可能并不需要。入门可以浏览一下这个网站掌握一些基本概念：<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/python">https://refactoringguru.cn/design-patterns/python</a> ，后续可以考虑阅读《Clean Architecture》，《重构》等相关数据，理解掌握在优化代码架构过程中思考的核心点，并加以运用。Python相关的设计模式应用，还可以参考《Python in Practice》。</p><p>自我考核：在项目中，找到一处可以应用设计模式的地方，进行重构改进。</p><h5 id="质量保障"><a href="#质量保障" class="headerlink" title="质量保障"></a>质量保障</h5><p>对于需要实际上线运行的软件工程，质量保障是非常重要的一个环节，能够确保整个产品按照期望的方式进行运作。在机器学习项目中，由于引入了数据这个因素，相比传统的软件测试会有更高的难度，也是业界还在摸索前进的方向。建议可以先阅读《单元测试的艺术》或《Google软件测试之道》，大致理解软件测试的一些基本概念和运作方式，在此基础上可以进一步阅读Martin Fowler对于机器学习领域提出的CD4ML中相关的测试环节，学习sklearn，LightGBM等开源库的测试开发方式，掌握机器学习相关的质量保障技术能力。</p><p>自我考核：在项目中，实现基础的数据输入测试，预测输出测试。</p><h5 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h5><p>软件工程推进过程中，项目管理相关的技能方法与工具运用也非常的关键。其中各种研发流程与规范，例如敏捷开发，设计评审，代码评审，版本管控，任务看板管理等，都是实际项目推进中非常重要的知识技能点。这方面推荐学习一本经典的软件工程教材《构建之法》，了解软件项目管理的方方面面。进一步来说广义的项目管理上的很多知识点也是后续深入学习的方向，可以参考极客时间上的课程《项目管理实战20讲》。</p><p>自我考核：在某个负责项目中运用项目管理方法，完成一个实际的需求评估，项目规划，设计与评审，开发执行，项目上线，监控维护流程，并对整个过程做复盘总结。</p><h5 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h5><p>软件工程师在技能方向成长的一条路线就是成为软件架构师，在这个方向上对于技能点会有非常高的综合性要求，其中也有不少高级话题需要深入学习和了解，例如技术选型与系统架构设计，架构设计原则与模式，宽广的研发知识视野，高性能，高可用，可扩展性，安全性等等。有兴趣的同学可以了解一下极客时间的《从0开始学架构》这门课，逐渐培养这方面的视野与能力。另外如《微服务架构设计模式》还有领域驱动设计方面的一系列书籍也值得参考学习。</p><p>自我考核：设计一个算法项目Docker镜像自动打包系统。</p><hr><h3 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h3><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><h5 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h5><p>在进行算法建模时，深入了解数据情况，做各类探索性分析，统计建模等工作非常重要，这方面对一些数学基础知识有一定的要求，例如概率论，统计学等。这方面除了经典的数学教材，也可以参考更程序员向的《统计思维》，《贝叶斯方法》，《程序员的数学2》等书籍。</p><p>自我考核：理解实际项目中的数据分布情况，并使用统计建模手段，推断预测值的置信区间。</p><h5 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h5><p>在进行数据分析时，可视化是一个非常重要的手段，有助于我们快速理解数据情况，发掘数据规律，并排查异常点。对于各种不同类型的数据，会对应不同的可视化最佳实践，如选择不同的图表类型，板式设计，分析思路编排，人机交互方式等等。另一方面，可视化与数据报告也是我们与不同角色人群沟通数据insights的一个重要途径，需要从业务角度出发去思考可视化与沟通方式。这方面可以参考《Storytelling with Data》，《The Visual Display of Quantitative Information》等经典数据，同时也需要培养自己的商业背景sense，提升沟通能力。</p><p>自我考核：对内沟通方面，能使用可视化技术，分析模型的bad case情况，并确定优化改进方向。对外沟通方面，能独立完成项目的数据分析沟通报告。</p><h5 id="误差分析与调优"><a href="#误差分析与调优" class="headerlink" title="误差分析与调优"></a>误差分析与调优</h5><p>在做算法模型调优改进中，需要从数据分析的基础上出发来决定实验方向，这么做有几个好处：</p><ul><li>从分析出发指导调优更有方向性，而不是凭经验加个特征，改个参数碰运气。哪怕是业务方提供的信息，也最好是有数据分析为前提再做尝试，而不是当成一个既定事实。</li><li>由分析发现的根源问题，对于结果验证也更有帮助。尤其在预测的数据量极大情况下，加一个单一特征很可能总体只有千分位准确率的提升，无法确定是天然波动还是真实的提升。但如果有分析的前提，那么我们可以有针对性的看对于这个已知问题，我们的调优策略是否生效，而不是只看一个总体准确率。</li><li>对于问题的彻底排查解决也更有帮助，有时候结果没有提升，不一定是特征没用，也可能是特征代码有bug之类的问题。带着数据分析的目标去看为什么这个特征没有效果，是模型没学到还是特征没有区分度等，有没有改进方案，对于我们评判调优尝试是否成功的原因也更能彻查到底。</li><li>数据分析会帮助我们发现一些额外的问题点，比如销量数据清洗处理是不是有问题，是不是业务本身有异常，需要剔除数据等。</li></ul><p>这方面在业界有一些关于误差分析的探索研究，不过大多数都是基于分类问题的，例如《Identifying Unknown Unknowns in the Open World》，《A Characterization of Prediction Errors》等。可以在了解这些研究的基础上，结合具体的业务情况，深入思考总结误差分析的思路与方法论。</p><p>自我考核：在项目中形成一套可以重复使用的误差分析方案，能够快速从预测输出中定位到目前模型最重要的误差类别，并一定程度上寻找到根本原因。</p><hr><h4 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h4><h5 id="传统机器学习"><a href="#传统机器学习" class="headerlink" title="传统机器学习"></a>传统机器学习</h5><p>这块大家应该都非常熟悉了，初阶的学习路线可以参考周志华老师的《机器学习》，涵盖了机器学习基础，常用机器学习方法，和一些进阶话题如学习理论，强化学习等。如果希望深化理论基础，可以参考经典的《PRML》，《ESL》和《统计学习方法》。在实战中，需要综合业务知识，算法原理，及数据分析等手段，逐渐积累形成建模调优的方法论，提高整体实验迭代的效率和成功率。</p><p>自我考核：结合实际业务和机器学习理论知识，挖掘项目中算法表现不够好的问题，并通过算法改造进行提升或解决。</p><h5 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h5><p>近些年兴起的深度学习，已经成为机器学习领域一个非常重要的分支，在各个应用方向发挥了很大的作用。相对于传统机器学习，对于特征工程要求的降低成了其核心优势。另一方面，深度学习对于大数据量，大规模算力的应用能力很强，也一定程度上提升了整体的产出效果。由于理论方面的研究稍显落后，深度学习在实际应用中对于使用者的经验技能要求相对比较高，需要有大量的实战经验才能达到比较理想的效果。这方面的学习资料推荐Keras作者的《Deep Learning with Python》，以及《Hands-on Machine Learning with Scikit-Learn and TensorFlow》，而在理论方面推荐著名的“花书”《Deep Learning》。在学习理论原理的基础上，尤其要注意在实际算法应用中，能够通过观察各种指标与数据分析，找到提升模型的操作改进方向。</p><p>自我考核：能够在实际项目中，使用深度学习模型，达到接近甚至超过传统GBDT模型的精确度效果，或者通过ensemble，embedding特征方式，提升已有模型的精度。</p><h5 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h5><p>目前我们的业务领域在时间序列预测，自然语言处理，推荐等方面，其它类似图像，搜索，广告等领域也都有各自的一些领域建模方法。在时间序列领域，包括了传统时序模型，如ARIMA, Prophet，机器学习模型，如划动窗口特征构建方法结合LightGBM，及深度学习模型，例如LSTM，seq2seq，transformer等。这方面可以参考Kaggle上相关比赛的方案分享，以及Amazon，Uber，天猫等有类似业务场景公司的分享资料。其它领域也是类似，通过了解历史技术演进，相关比赛，业界的方案分享与开源项目，会议论文来逐渐掌握学习建模方法，结合实际业务进行实践尝试，积累起更加体系性的个人知识技能。</p><p>自我考核：在项目中复现一个Kaggle获胜方案，检验其效果，分析模型表现背后的原因，并尝试进行改进。</p><hr><h4 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h4><h5 id="数据处理框架"><a href="#数据处理框架" class="headerlink" title="数据处理框架"></a>数据处理框架</h5><p>在项目实施过程中，会需要各类复杂的数据处理操作，因此熟练掌握此类框架就显得尤为重要。目前行业的标准基本上会参照Pandas DataFrame的定义，在数据量较大的情况下，也有许多类似的框架，如Spark，Dask，Modin，Mars等支持分布式运行的DataFrame，以及cuDF，Vaex等提升单机性能的改进实现。这方面经典的书籍可以参考Wes McKinney的《Python for Data Analysis》，在掌握基础数据操作的基础上，可以进而了解窗口函数，向量化性能优化等高级话题。另外SQL也可以做非常复杂的数据处理工作，有不少公司例如阿里会以SQL为主来构建数据处理流程，感兴趣的同学也可以学习一下SQL中各种高级计算的使用及优化方法。</p><p>自我考核：在已有项目中，能把至少三个使用apply方法的pandas处理修改成向量化运行，并测试性能提升。使用window function或其它方案来实现lag特征，减少join次数。</p><h5 id="机器学习框架"><a href="#机器学习框架" class="headerlink" title="机器学习框架"></a>机器学习框架</h5><p>机器学习方面的新框架层出不穷，一方面我们需要掌握经典框架的使用方式，理解其模块构成，接口规范的设计，一定程度上来说其它新框架也都需要遵循这些业界标准框架的模块与接口定义。另一方面对于新框架或特定领域框架，我们需要掌握快速评估，上手使用，并且做一定改造适配的能力。一些比较经典的框架有：</p><ul><li>通用机器学习：scikit-learn，Spark ML，LightGBM</li><li>通用深度学习：Keras&#x2F;TensorFlow，PyTorch</li><li>特征工程：tsfresh, Featuretools，Feast</li><li>AutoML：hyperopt，SMAC3，nni，autogluon</li><li>可解释机器学习：shap，aix360，eli5，interpret</li><li>异常检测：pyod，egads</li><li>可视化：pyecharts，seaborn</li><li>数据质量：cerberus，pandas_profiling，Deequ</li><li>时间序列：fbprophet，sktime，pyts</li><li>大规模机器学习：Horovod，BigDL，mmlspark</li><li>Pipeline：MLflow, metaflow，KubeFlow，Hopsworks</li></ul><p>一般的学习路径主要是阅读这些框架的官方文档和tutorial，在自己的项目中进行尝试使用。对于一些核心接口，也可以阅读一下相关的源代码，深入理解其背后的原理。</p><p>自我考核：在LightGBM框架下，实现一个自定义的损失函数，并跑通训练与预测流程。</p><hr><h5 id="其它框架"><a href="#其它框架" class="headerlink" title="其它框架"></a>其它框架</h5><p>其它比较常见且与算法工程师日常工作会有一些联系的有Web框架，爬虫框架等，最具有代表性的当属Flask和scrapy。这两者背后各自又是很大一块领域，尤其web开发更是保罗万象。感兴趣的同学还可以了解一下一些新兴的基于Python3的框架，例如FastAPI，其背后借鉴的许多现代框架的思想设计，包括数据验证，序列化，自动文档，异步高性能等，开拓一下知识面。</p><p>自我考核：实现一个简单的model serving http服务。</p><hr><h3 id="算法工程交叉"><a href="#算法工程交叉" class="headerlink" title="算法工程交叉"></a>算法工程交叉</h3><h4 id="大规模算法运行"><a href="#大规模算法运行" class="headerlink" title="大规模算法运行"></a>大规模算法运行</h4><h5 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h5><p>在很多项目中，数据量达到十亿级以上的情况下，单机训练会难以支撑。因此分布式训练也是实际工程落地中非常重要的一个主题。分布式训练涉及到多机的通讯协同方式，优化算法的改造，数据及模型的并行与聚合，以及框架的选择和运维等话题，具体可以参考《分布式机器学习》。另外对于分布式系统，也可以参阅《数据密集型应用系统设计》这本神作，了解其背后原理。</p><p>自我考核：能够在多机上进行亿级数据的GBDT模型训练与预测。</p><h5 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h5><p>在做大规模的数据训练与推理时，近些年涌现出许多高性能计算优化的方法，例如从硬件方面，有各种超线程技术，向量化指令集，GPGPU，TPU的应用等，从软件方面，有针对数值计算场景的OpenBLAS，有自动并行化的OpenMP，有各种codegen，JIT技术下的运行时优化等。这方面可以学习的方向也很多，从基础的并行编程，编译原理及优化的知识开始，到CUDA，OpenMP的应用（例如Nvidia的cuDNN，还有LightGBM中也用到了OpenMP），Codegen，JIT等技术在Spark，TVM等项目中的使用等，建议有深度性能优化需求时可以往这些方向做调研和学习。</p><p>自我考核：能够通过LLVM JIT来优化实现Spark window function的执行性能。</p><h5 id="模型加速领域"><a href="#模型加速领域" class="headerlink" title="模型加速领域"></a>模型加速领域</h5><p>这个方向分两个部分，一块是模型训练方面，能够做到加速，例如使用大batch size，迁移学习，持续的在线&#x2F;增量学习等手段，另一块在模型预测方面，也有很多加速需求，比如模型参数量优化，模型压缩，混合精度，知识蒸馏等技术手段，都是为了做到更高性能，更低资源消耗的模型预测推理。这方面业界有各个方向的文章和技术实现可以参考，比如经典的《Training ImageNet in 1 Hour》，MobileNet，TensorRT，二值网络等。</p><p>自我考核：在典型的销量预测场景中实现增量训练与预测。</p><hr><h4 id="MLOps"><a href="#MLOps" class="headerlink" title="MLOps"></a>MLOps</h4><h5 id="编排调度"><a href="#编排调度" class="headerlink" title="编排调度"></a>编排调度</h5><p>包含各类pipeline的编排与调度能力的支持，包括数据pipeline，训练pipeline和serving pipeline等。这方面比较常用的框架工具有Airflow，DolphinScheduler，Cadence等，需要掌握其基本的工作原理和使用方式，并能够应用于离线实验与线上运行。</p><p>自我考核：使用Airflow完成一个标准的项目pipeline搭建与运行。</p><h5 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h5><p>相对于传统的DevOps，机器学习项目最大的区别在于数据方面的依赖会更加显著与重要。这方面的话题包括数据血缘，数据质量保障，数据版本控制等，有各类工具可以借鉴使用，例如数据版本管理方面的DVC，数据质量方面的TFX Data Validation，Cerberus，Deequ等。在方法论层面，《The ML Test Score》中给出了不少数据相关的具体测试方法，值得参考学习。</p><p>自我考核：在项目中实现输入数据的分布测试，特征工程测试及特征重要性准入测试。</p><h5 id="实验管理"><a href="#实验管理" class="headerlink" title="实验管理"></a>实验管理</h5><p>这部分也是ML项目的独特之处，在开发过程中有大量的实验及相应的结果输出需要记录，以指导后续调整优化的方向，并选择最优结果来进行上线部署。这方面可以参考的项目有MLflow，fitlog，wandb等。当然对于单独的项目来说，可能online Excel就能满足需求了 :)</p><p>自我考核：在实际项目中实行一套标准的实验记录手段，并能从中找出各类实验尝试带来的精度提升的top 5分别是哪些操作。</p><h5 id="Serving"><a href="#Serving" class="headerlink" title="Serving"></a>Serving</h5><p>目前我们的serving大多数是离线batch预计算的形式，所以主要依赖的技术手段是各类离线inference的方法，例如直接使用model predict接口，使用mmlspark等做大规模并行inference等。如果涉及到在线serving，情况会更加复杂，例如在线pipeline的运行，实时特征获取，low latency&#x2F;high throughput的serving服务等，可以参考TF Serving，MLeap，H2O，PredictionIO，PMML&#x2F;PFA&#x2F;ONNX等开发标准模型格式等。</p><p>自我考核：部署一个实时预测服务，能够根据用户输入产生相应的预测结果。</p><h5 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h5><p>软件工程中的持续集成，持续部署已经成为一种标准实践，在算法项目中，额外引入了数据这个维度的复杂性，带来了一些新的挑战。在这个方向上，几个主要话题包括自动化测试，pipeline打包部署，持续监控运维等，可以参考Martin Fowler关于CD4ML的文章。工具系统层面，可以学习传统的Jenkins，也有一些新选择例如CircleCI，GoCD，VerCD（Uber）等。</p><p>自我考核：通过Jenkins实现pipeline自动测试，打包，上线流程。</p><h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><p>在整个项目上线后，需要对系统的各个环节进行监控，并对各种异常情况作出响应。例如输入数据的监控，判别测试数据与训练数据的分布是否有偏移，整个运行pipeline的监控，判别是否有运行失败抛出异常的情况，对于预测输出的监控，确保没有异常的预测输出值，也包括对于系统计算资源等方面的监控，确保不会因为资源不足导致业务受到影响等。在监控信息收集，基础上，还需要配套一系列的自动告警通知，日志追踪排查等。这方面的工具框架包括TF data validation这类专门针对算法项目的新产品，也有elasicsearch + kibana这类传统产品。</p><p>自我考核：将三个项目中做过的问题排查改造成常规监控手段，支持自动的问题发现，告警通知，如有可能，提供自动化或半自动化的问题排查解决方案。</p><h5 id="MLOps系统"><a href="#MLOps系统" class="headerlink" title="MLOps系统"></a>MLOps系统</h5><p>MLOps整体是一个比较大的话题，在这方面有很多产品和系统设计方面的实践可以参考学习。例如Uber的Michelangelo系列文章，Facebook的FBLearner，neptune.ai，dataiku，domino等，虽然没有开源，但是其背后的很多设计理念，演进思考，白皮书等都非常值得我们学习。在开源界也有很多可以参考的项目，例如MLflow，Kubeflow，Metaflow，TFX等，可以学习他们的设计理念，Roadmap，以及实现细节等。</p><p>自我考核：总结各个MLOps产品的功能模块矩阵对比，能够根据项目需求来进行产品选型与使用。</p><hr><h3 id="工程深入方向"><a href="#工程深入方向" class="headerlink" title="工程深入方向"></a>工程深入方向</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><h5 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h5><p>在平时工作中，我们有大量的场景需要用到数据库。从客户数据的对接，数据集的管理和使用，到各种业务系统的数据表设计及优化等，都需要对数据库的运作原理，适用场景，运维使用，性能优化等方面有一定的了解。常见的需要掌握的概念有OLTP vs OLAP，事务，索引，隔离级别，ACID与CAP理论，数据同步，数据分片，SQL语法，ORM等。从底层原理看，会涉及到数据，索引，及日志等存储引擎方面，以及各种计算查询引擎，包括分布式系统的设计与实现。这方面推荐的学习资料有《数据库系统内幕》及《数据密集型应用系统设计》。</p><p>自我考核：能够理解SQL执行计划，并能够根据执行计划来做索引或查询调优。</p><h5 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h5><p>目前常用的关系型数据库主要是MySQL和PostgreSQL，主要需要掌握的是日常的一些SQL操作，例如DML（增删改查），DDL（创建表，修改索引等），DCL（权限相关）。在此基础上还可以进一步了解一些如数据类型，高级计算，存储引擎，部署运维，范式概念与表结构设计等方面的话题。对于高级话题这块，推荐《高性能MySQL》与《高可用MySQL》。</p><p>自我考核：在MySQL中设计相关表结构，存储实际项目中的一系列中间数据集。</p><h5 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h5><p>常用的NoSQL数据库有几类，KV存储（Redis），文档数据库（MongoDB），Wide-column存储（Cassandra，HBase）以及图数据库（Neo4j）。在目前我们的算法项目中，比较有可能会用到的主要是Redis这类KV存储（也可能把Cassandra之类当泛KV来用），或者更新一点的类似Delta Lake的存储系统。建议学习了解一下这类KV存储，以及分布式数据库的常见操作方式，以及基础的运维排查，性能优化方法。</p><p>自我考核：考虑一个线上模型服务的场景，用户输入作为基础特征，使用类似Redis的KV系统，实现实时获取其它特征，并进行模型预测。</p><hr><h4 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h4><h5 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h5><p>IT系统总体的发展趋势在往云计算方向演进，即使是自建的基础设施，也会采用云计算的一套构建方式，让开发者不用过多的关注底层计算存储资源的部署运维。对于应用开发者来说，需要了解一些基础架构方面的知识，例如各类虚拟化及容器技术，配置管理，容器编排等，便于在日常工作中使用相关技术来管理和发布应用。从工具层面看，Docker与k8s等技术发展速度较快，主要还是根据官方文档来学习为主。浙大之前出版的《Docker - 容器与容器云》一书中有一些更深入的话题的探讨，另外《Kubernetes in Action》中也值得一读。从方法论层面看，《Infrastructure as Code》和《Site Reiliability Engineering》是两本非常不错的学习资料。与算法应用结合的虚拟化，运维，持续集成等都是比较新的领域，需要我们探索出一条可行路线。</p><p>自我考核：对于已有的算法项目，总结制定一套开发，测试，发布，运维的标准流程，且尽可能自动化执行。</p><h5 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h5><p>前些年最流行的分布式存储是脱胎于Google经典的GFS论文实现的HDFS，不过随着硬件技术的发展，计算存储分离思想的逐渐兴起，不但灵活性更高，成本更低，且各自架构的复杂度也大大降低了。因此目前更建议学习简单的object store形式的分布式存储，例如s3，minio等。在此基础上的一些存储系统，例如Delta Lake，提供了事务，高效的upsert，time travel等功能，也值得关注与学习。原理方面，还是推荐《数据密集型应用设计》这本。</p><p>自我考核：在项目中实现不同机器能够访问同一个s3路径的文件，并进行正常的数据读写，模型文件读写等功能。</p><h5 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h5><p>大数据时代的分布式计算的鼻祖来自于Google经典的MapReduce论文，后续在Hadoop系统中做了开源实现，在前几年是非常火热的一项技术。目前业界的主流是Spark和Flink，前者在批处理计算中处于霸者地位，后者是流处理领域的领先者。目前我们的业务应用中，Spark是比较常用的分布式计算引擎，其基本操作相关内容比较简单，参考官方文档或者《Spark快速大数据分析》即可。后续的主要难点会有大数据量下的问题排查与性能调优，执行复杂计算或与Python相关UDF的交互配合方式等。这方面需要对Spark的系统架构，内部原理有一定了解，例如master，worker，driver，executor等之间的关系，lazy evaluation，DAG的lineage与stage概念，shuffle优化，wholestage codegen等技术细节。这方面暂时没有找到比较好的资料，主要还是依赖实际问题解决的经验积累。</p><p>自我考核：用Spark来实现项目中的特征工程，并在一定数据量情况下取得比单机Pandas更好的性能效果。</p><h5 id="其它话题"><a href="#其它话题" class="headerlink" title="其它话题"></a>其它话题</h5><p>其它云服务基础设施还包括分布式数据库，消息队列，zk&#x2F;raft分布式协作系统，虚拟网络，负载均衡等。这些话题离算法应用方面会比较远一些，基本上达到遇到需求时会使用的能力即可，在这里不做展开。</p><hr><h3 id="算法深入方向"><a href="#算法深入方向" class="headerlink" title="算法深入方向"></a>算法深入方向</h3><h4 id="AutoML"><a href="#AutoML" class="headerlink" title="AutoML"></a>AutoML</h4><h5 id="超参优化"><a href="#超参优化" class="headerlink" title="超参优化"></a>超参优化</h5><p>自动化机器学习中比较传统的一块是超参数优化，进而可以推广到整个pipeline的超参优化，包括数据预处理，特征工程，特征选择，模型选择，模型调优，后处理等部分。目前业界应用比较广泛的技术手段主要是随机搜索，贝叶斯优化，进化算法，Hyperband&#x2F;BOHB等，在特征工程方面有Featuretools，tsfresh，AutoCross等自动化特征工程工具。学术界有一些进一步的探索研究，包括multi-fidelity优化，多任务优化，HPO结合ensemble learning，pipeline planning，data diff自动数据分布探测等方面。可以参考<a target="_blank" rel="noopener" href="http://automl.org上的各类参考资料与书籍进行学习了解.主要难点包括automl算法的泛化能力,scalability,整体pipeline组合的搜索与生成,针对不同学习算法的自动优化手段等./">http://automl.org上的各类参考资料与书籍进行学习了解。主要难点包括automl算法的泛化能力，scalability，整体pipeline组合的搜索与生成，针对不同学习算法的自动优化手段等。</a></p><p>自我考核：了解超参优化的基础概念，能够在项目中应用框架工具来实现模型超参的贝叶斯优化流程。</p><h5 id="元学习"><a href="#元学习" class="headerlink" title="元学习"></a>元学习</h5><p>Meta learning是近年来非常活跃的一个新兴领域，其主要思路是希望能通过元学习模型方法，去积累建模调优的先验知识，跨任务推断模型效果并warm start新的训练任务，或者指导学习算法来进行更高效的具体任务的训练过程。这方面在工业界的主要应用基本上集中在建模调优先验知识的积累方面，比如通过一系列公开数据集搜索寻找出表现较好的起始参数，用于指导在新任务上做超参优化的起始搜索点。学术研究中除了configuration space的研究，还包括从learning curve中进行学习推断，元特征提取与建模，HTN planning在pipeline构建中的应用，以及MAML等few-shot learning方向的探索。这方面推荐Lilian Weng的一系列文章（<a target="_blank" rel="noopener" href="https://lilianweng.github.io/lil-log/2018/11/30/meta-learning.html%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8Ahttp://automl.org%E7%BD%91%E7%AB%99%E4%B8%8A%E7%9A%84%E8%B5%84%E6%96%99%E3%80%82">https://lilianweng.github.io/lil-log/2018/11/30/meta-learning.html），以及http://automl.org网站上的资料。</a></p><p>自我考核：设计一系列meta feature与meta learning手段，实现对新任务的参数选择的初始化。</p><h5 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h5><p>AutoML领域比较火，但也是比较特别的一个方向，目前需要大量的计算资源投入才能做这方面的研究与尝试，因此主要建议了解一下这个方向的一些工作即可，不做深入探索学习。</p><h5 id="AutoML系统"><a href="#AutoML系统" class="headerlink" title="AutoML系统"></a>AutoML系统</h5><p>自动化机器学习相关的框架工具也非常多，比较有代表性的框架有auto-sklearn(来自<a target="_blank" rel="noopener" href="http://automl.org团队),nni(microsoft),auto-gluon(amazon),h2o,ray/">http://automl.org团队)，nni(microsoft)，auto-gluon(amazon)，H2O，ray</a> tune等，在工具级别也有如hyperopt，SMAC3，featuretools等。可以通过学习这些工具框架，了解AutoML系统的架构与实现方式，并应用到实际项目中。</p><p>自我考核：使用一种AutoML系统来进行项目的模型自动优化，并与手工优化的结果进行比较，看是否有所提升，及寻找背后的原因。</p><hr><h4 id="模型解释"><a href="#模型解释" class="headerlink" title="模型解释"></a>模型解释</h4><h5 id="模型解释技术"><a href="#模型解释技术" class="headerlink" title="模型解释技术"></a>模型解释技术</h5><p>主要有三个方面，一是模型本身的解释性，例如线性回归，决策树等，模型结构简单，根据其原理，可以直接对预测结果，特征使用等方面给出解释。另外一些复杂模型，例如EBM，神经网络，Bayesian rule lists，SLIMs等，也可以利用一些本身的特性给出一些解释，例如GradCAM方法等。二是模型无关的解释方法，包括经典的PDP，ICE等特征图，LIME等surrogate model方法，以及基于博弈论的Shapley方法。三是基于sample的解释方法，例如conterfactual explanations，adversarial examples，prototypes，influential instances，kNN等，不过看起来这类方法对于计算的开销一般都会比较大，不太容易在工程中实现落地。这方面的资料可以学习《Interpretable Machine Learning》和《Explainable AI》（关于深度学习的内容会更多）。另外学术界也有很多前沿探索，比如针对模型解释的降维工作，自动的时间序列分析及报告生成，因果模型，模型公平性及社会影响等方面，可以保持关注。</p><p>自我考核：理解LIME，Shapley的运作原理，并分析其局限性，尝试提出改进方案。</p><h5 id="模型解释应用"><a href="#模型解释应用" class="headerlink" title="模型解释应用"></a>模型解释应用</h5><p>从工具框架方面，有许多可以使用的开源项目，例如微软的interpret，eli5，shap，AIX360等。另外也有一些非传统意义上的模型解释，例如manifold，tensorboard这类模型debugging工具，自动化的误差分析与模型改进方案，因果模型框架，模型公平性评估与纠正工具等，都可以涵盖在广义的模型解释领域中。在工具基础上，如何结合业务领域知识，给出更有针对性的解释方案，也是值得思考深挖的方向。</p><p>自我考核：使用shap，eli5等工具来进行模型解释，并在此基础上形成面向开发者的模型debug，误差分析及改进方案，或形成面向业务的what-if分析看板。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前机器学习应用领域还在高速发展与演进过程中，除了上述提到的技能方向，后续很可能会不断有新的主题引入进来，需要练就快速学习并应用落地的能力。在掌握前面编程，软件工程，机器学习的基础上，后半部分的研究方向，大家可以根据个人兴趣，选择几个进行深入探索与实践。仅阅读相关书籍和文章，只能对知识内容有一个初步的认识，必须要通过深入的动手实践，反复试错思考和修正，才能逐渐内化为自己的技能，并构建起较为坚实的知识体系。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv23104135/">https://www.bilibili.com/read/cv23104135/</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/people/zijie0">https://www.zhihu.com/people/zijie0</a></p></blockquote></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/7d43867c.html" rel="prev" title="摄影新手第一次买微单相机怎么选？2023年入门相机推荐买什么牌子的好？"><i class="fa fa-chevron-left"></i> 摄影新手第一次买微单相机怎么选？2023年入门相机推荐买什么牌子的好？</a></div><div class="post-nav-item"><a href="/df0b01d8.html" rel="next" title="脑电图生物标志物在意识障碍临床结果检测中的准确性">脑电图生物标志物在意识障碍临床结果检测中的准确性 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let t=CONFIG.comments["activeClass"];var e;(t=CONFIG.comments.storage?localStorage.getItem("comments_active")||t:t)&&(e=document.querySelector(`a[href="#comment-${t}"]`))&&e.click()}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%83%BD%E5%8A%9B%E5%B1%82%E7%BA%A7%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">工程师能力层级概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%85%E8%AF%BB%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">阅读建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">工程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">3.1.</span> <span class="nav-text">编程语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Python"><span class="nav-number">3.1.1.</span> <span class="nav-text">Python</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scala-x2F-Java"><span class="nav-number">3.1.2.</span> <span class="nav-text">Scala&#x2F;Java</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-x2F-C-x2F-Rust"><span class="nav-number">3.1.3.</span> <span class="nav-text">C&#x2F;C++&#x2F;Rust</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.2.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux%E5%9F%BA%E7%A1%80"><span class="nav-number">3.2.2.</span> <span class="nav-text">Linux基础</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8"><span class="nav-number">3.2.3.</span> <span class="nav-text">深入应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">软件工程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.</span> <span class="nav-text">算法与数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.2.</span> <span class="nav-text">代码规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%A8%E9%87%8F%E4%BF%9D%E9%9A%9C"><span class="nav-number">3.3.4.</span> <span class="nav-text">质量保障</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.5.</span> <span class="nav-text">项目管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98"><span class="nav-number">3.3.6.</span> <span class="nav-text">高级话题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">4.</span> <span class="nav-text">算法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">数据分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="nav-number">4.1.1.</span> <span class="nav-text">数学基础</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">4.1.2.</span> <span class="nav-text">可视化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="nav-number">4.1.3.</span> <span class="nav-text">误差分析与调优</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80"><span class="nav-number">4.2.</span> <span class="nav-text">机器学习基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">4.2.1.</span> <span class="nav-text">传统机器学习</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="nav-number">4.2.2.</span> <span class="nav-text">深度学习</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1"><span class="nav-number">4.2.3.</span> <span class="nav-text">领域建模</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">4.3.</span> <span class="nav-text">算法框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6"><span class="nav-number">4.3.1.</span> <span class="nav-text">数据处理框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6"><span class="nav-number">4.3.2.</span> <span class="nav-text">机器学习框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%A1%86%E6%9E%B6"><span class="nav-number">4.3.3.</span> <span class="nav-text">其它框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E4%BA%A4%E5%8F%89"><span class="nav-number">5.</span> <span class="nav-text">算法工程交叉</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%AE%97%E6%B3%95%E8%BF%90%E8%A1%8C"><span class="nav-number">5.1.</span> <span class="nav-text">大规模算法运行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83"><span class="nav-number">5.1.1.</span> <span class="nav-text">分布式训练</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97"><span class="nav-number">5.1.2.</span> <span class="nav-text">高性能计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E5%8A%A0%E9%80%9F%E9%A2%86%E5%9F%9F"><span class="nav-number">5.1.3.</span> <span class="nav-text">模型加速领域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MLOps"><span class="nav-number">5.2.</span> <span class="nav-text">MLOps</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E6%8E%92%E8%B0%83%E5%BA%A6"><span class="nav-number">5.2.1.</span> <span class="nav-text">编排调度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90"><span class="nav-number">5.2.2.</span> <span class="nav-text">数据集成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%AE%A1%E7%90%86"><span class="nav-number">5.2.3.</span> <span class="nav-text">实验管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Serving"><span class="nav-number">5.2.4.</span> <span class="nav-text">Serving</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CI-x2F-CD"><span class="nav-number">5.2.5.</span> <span class="nav-text">CI&#x2F;CD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7"><span class="nav-number">5.2.6.</span> <span class="nav-text">系统监控</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MLOps%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.2.7.</span> <span class="nav-text">MLOps系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E6%B7%B1%E5%85%A5%E6%96%B9%E5%90%91"><span class="nav-number">6.</span> <span class="nav-text">工程深入方向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.1.</span> <span class="nav-text">数据库原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.1.2.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">6.1.3.</span> <span class="nav-text">NoSQL数据库</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="nav-number">6.2.</span> <span class="nav-text">云计算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">基础架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">6.2.2.</span> <span class="nav-text">分布式存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">6.2.3.</span> <span class="nav-text">分布式计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E8%AF%9D%E9%A2%98"><span class="nav-number">6.2.4.</span> <span class="nav-text">其它话题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B7%B1%E5%85%A5%E6%96%B9%E5%90%91"><span class="nav-number">7.</span> <span class="nav-text">算法深入方向</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AutoML"><span class="nav-number">7.1.</span> <span class="nav-text">AutoML</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E5%8F%82%E4%BC%98%E5%8C%96"><span class="nav-number">7.1.1.</span> <span class="nav-text">超参优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E5%AD%A6%E4%B9%A0"><span class="nav-number">7.1.2.</span> <span class="nav-text">元学习</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NAS"><span class="nav-number">7.1.3.</span> <span class="nav-text">NAS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AutoML%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.1.4.</span> <span class="nav-text">AutoML系统</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A"><span class="nav-number">7.2.</span> <span class="nav-text">模型解释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A%E6%8A%80%E6%9C%AF"><span class="nav-number">7.2.1.</span> <span class="nav-text">模型解释技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A%E5%BA%94%E7%94%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">模型解释应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Aisaka Aoi" src="/images/manatsu.jpg"><p class="site-author-name" itemprop="name">Aisaka Aoi</p><div class="site-description" itemprop="description">逢坂葵的个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1023</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">20</span> <span class="site-state-item-name">分类</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/AisakaAoi" title="GitHub 👨‍💻 → https:&#x2F;&#x2F;github.com&#x2F;AisakaAoi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub 👨‍💻</a> </span><span class="links-of-author-item"><a href="https://github.com/Aisakaorz" title="GitHub 👩‍💻 → https:&#x2F;&#x2F;github.com&#x2F;Aisakaorz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub 👩‍💻</a> </span><span class="links-of-author-item"><a href="mailto:aisakaaoi@qq.com" title="E-Mail 📧 → mailto:aisakaaoi@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail 📧</a> </span><span class="links-of-author-item"><a href="mailto:chenzongnan@m.scnu.edu.cn" title="E-Mail 🏫 → mailto:chenzongnan@m.scnu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail 🏫</a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/91560309" title="Bilibili 📺 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;91560309" rel="noopener" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili 📺</a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/198562921" title="Bilibili 🎮 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;198562921" rel="noopener" target="_blank"><i class="fab fa-bilibili fa-fw"></i>Bilibili 🎮</a> </span><span class="links-of-author-item"><a href="https://www.youtube.com/channel/UCALvyn5Cl76GCotO9pczvjg" title="YouTube 📺 → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCALvyn5Cl76GCotO9pczvjg" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube 📺</a></span></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2026</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Aisaka Aoi</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">4m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">164:56</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{var t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>e+"="+encodeURIComponent(t)).join("&"),r="/lib/pdf/web/viewer.html?file="+encodeURIComponent(t)+a;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${r}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!0,notify:!0,appId:"UqjWdRYbIUEUQRXhBUUIh1QE-gzGzoHsz",appKey:"gj89JXC485PFbpdHLKVkz6dm",placeholder:"这里可以发送评论~（上面可以输入昵称、邮箱）",avatar:"mm",meta:e,pageSize:"10",visitor:!0,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/assets/haru02.model.json"},display:{position:"right",width:208,height:520},mobile:{show:!1},log:!1})</script></body></html>